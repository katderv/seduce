--- /tmp/libemu/src/emu_shellcode.c	2021-10-02 21:49:47.953155209 +0300
+++ libemu/src/emu_shellcode.c	2021-10-02 21:42:00.061876135 +0300
@@ -57,94 +57,13 @@
 		return 0;
 	else
 	if ( ((struct emu_stats *)a->data)->cpu.steps == ((struct emu_stats *)b->data)->cpu.steps )
-		if ( ((struct emu_stats *)a->data)->eip < ((struct emu_stats *)b->data)->eip )
+    	if ( ((struct emu_stats *)a->data)->eip <= ((struct emu_stats *)b->data)->eip )
 			return 0;
 
 	return 1;
 }
 
 
-/**
- * This function takes the emu, the offset and tries to run 
- * steps iterations. If it fails due to uninitialized 
- * registers/eflags it will try to use the information passed by 
- * etas to traverse the instruction tree and find an instruction
- * path in the tree which satisfies the initialization 
- * requirements.
- *  
- * To avoid testing the same positions over and over, the 
- * already-tested positions are held in the known_positions 
- * hashtable.
- *  
- * The result is returned in the tested_positions_list.
- * 
- *  
- * The function is called for every GetPC candidate in the 
- * suspected shellcode, therefore the known_positions prevent 
- * testing the same locations for different starting points in 
- * the data too.
- *  
- * It is the vital part of libemu's shellcode detection, hard to
- * understand, hard to improve and hard to fix.
- *  
- * Messing this function up, destroys libemu's shellcode 
- * detection.
- *  
- * The function is a mess, given the complexity of the loops it 
- * is too long and the variable names do not provide any help.
- *  
- * The bruteforce flag is useful, as it allows bfs even if some 
- * instructions initializations are not set properly, but you'll 
- * definitely miss its impact on the behaviour when making a 
- * guess why something does not work. 
- *  
- * short explanation of the logic: 
- *  
- * the first starting point is our offset 
- *  
- * while we have starting points: 
- *     run the shellcode: error?
- *  	   no!
- * 		   continue
- *     yes!
- *     use the current starting eip as starting point to bfs 
- *     look for instructions which satisfy the requirements OR
- *     brutefore
- * 	       queue these new instructions as starting points
- *  
- *  
- *  
- * History has proven the the function to be susceptible to 
- * denial of service attacks, running the system out of memory 
- * or cycles. 
- * So, if you experience a 'problem', this is the first place to 
- * look at, and the last one you want to look at, if you want to
- * cause a 'problem', same rules apply. 
- *  
- * This comment was written when patching one of these dos 
- * problems 
- * The known_positions arg has been unused for the time before, 
- * seems like there was a good idea when writing the function 
- * initially, but this good idea was abandoned once 'it worked'
- *  
- * 
- * 
- * @param e         the emu to run
- * @param data      the data we run
- * @param datasize  the data size
- * @param eipoffset the offset for eip
- * @param steps     how many steps to try running
- * @param etas      the track and source tree - the substantial
- *                  information to run the breath first search
- * @param known_positions
- *                  already tested positions
- * @param stats_tested_positions_list
- *                  the result list
- * @param brute_force
- *                  be aggressive?
- * 
- * @return 
- */
 int32_t     emu_shellcode_run_and_track(struct emu *e, 
 										uint8_t *data, 
 										uint16_t datasize, 
@@ -168,16 +87,6 @@
 
 	struct emu_env *env = NULL;
 
-	{ // mark all vertexes white
-
-		struct emu_vertex *x;
-		for ( x= emu_vertexes_first(etas->static_instr_graph->vertexes); !emu_vertexes_attail(x); x = emu_vertexes_next(x))
-		{
-			x->color = white;
-		}
-
-	}		 
-
 	while ( !emu_queue_empty(eq) )
 	{
 		
@@ -186,7 +95,7 @@
 		/* init the cpu/memory 
 		 * scooped to keep number of used varnames small 
 		 */
-        {
+        	{
 			logDebug(e, "running at offset %i %08x\n", current_offset, current_offset);
 
 			emu_memory_clear(mem);
@@ -208,8 +117,6 @@
 
 			/* set the flags */
 			emu_cpu_eflags_set(cpu,0x0);
-
-			cpu->tracking = etas;
 		}
 
 		emu_tracking_info_clear(&etas->track);
@@ -281,17 +188,19 @@
 							emu_tracking_info_diff(&cpu->instr.track.need, &etas->track, eti);
 							eti->eip = current_offset;
 							emu_tracking_info_debug_print(eti);
+							emu_queue_enqueue(bfs_queue, eti);
+						}
+
+/*						{ // mark all vertexes white
 
-							if( emu_hashtable_search(known_positions, (void *)(uintptr_t)(uint32_t)current_offset) != NULL)
+							struct emu_vertex *x;
+							for ( x= emu_vertexes_first(etas->static_instr_graph->vertexes); !emu_vertexes_attail(x); x = emu_vertexes_next(x))
 							{
-								logDebug(e, "Known %p %x\n", eti, eti->eip);
-								emu_tracking_info_free(eti);
-								emu_queue_free(bfs_queue);
-								break;
+								x->color = white;
 							}
 
-							emu_queue_enqueue(bfs_queue, eti);
 						}
+*/
 						while ( !emu_queue_empty(bfs_queue) )
 						{
 							logDebug(e, "loop %s:%i\n", __FILE__, __LINE__);
@@ -307,26 +216,11 @@
 							struct emu_vertex *current_pos_v = (struct emu_vertex *)current_pos_ht->value;
 							struct emu_source_and_track_instr_info *current_pos_satii = (struct emu_source_and_track_instr_info *)current_pos_v->data;
 
-							if( emu_hashtable_search(known_positions, (void *)(uintptr_t)(uint32_t)current_pos_satii->eip) != NULL )
-							{
-								logDebug(e, "Known Again %p %x\n", current_pos_satii, current_pos_satii->eip);
-								current_pos_v->color = red;
-								emu_tracking_info_free(current_pos_ti_diff);
-								continue;
-							}
-
 							if (current_pos_v->color == red)
-							{
-								logDebug(e, "is red %p %x: %s\n", (uintptr_t)current_pos_v, current_pos_satii->eip, current_pos_satii->instrstring);
-								emu_tracking_info_free(current_pos_ti_diff);
 								continue;
-							}
 
-							logDebug(e, "marking red %p %x: %s \n", (uintptr_t)current_pos_v, current_pos_satii->eip, current_pos_satii->instrstring);
 							current_pos_v->color = red;
 
-							emu_hashtable_insert(known_positions, (void *)(uintptr_t)(uint32_t)current_pos_satii->eip, NULL);
-
 							while ( !emu_tracking_info_covers(&current_pos_satii->track.init, current_pos_ti_diff) || brute_force )
 							{
 								logDebug(e, "loop %s:%i\n", __FILE__, __LINE__);
@@ -343,28 +237,13 @@
 									for ( ee = emu_edges_first(current_pos_v->backedges); !emu_edges_attail(ee); ee=emu_edges_next(ee) )
 									{
 										ev = ee->destination;
-										/**
-										 * ignore positions we've visited already 
-										 * avoids dos for jz 0 
-										 *  
-										 * try the next position instead 
-										 */
-										if( ev->color == red )
-											continue;
-
-										struct emu_source_and_track_instr_info *next_pos_satii =  (struct emu_source_and_track_instr_info *)ev->data;
-										
-
-										
-
-										logDebug(e, "EnqueueLoop %p %x %s\n", next_pos_satii, next_pos_satii->eip, next_pos_satii->instrstring);
 										struct emu_tracking_info *eti = emu_tracking_info_new();
 										emu_tracking_info_diff(current_pos_ti_diff, &current_pos_satii->track.init, eti);
-										eti->eip = next_pos_satii->eip;
+										eti->eip = ((struct emu_source_and_track_instr_info *)ev->data)->eip;
 										emu_queue_enqueue(bfs_queue, eti);
+
 									}
-									/**
-									 * the new possible positions and requirements got queued into the bfs queue, 
+									/* the new possible positions and requirements got queued into the bfs queue, 
 									 *  we break here, so the new queued positions can try to work it out
 									 */
 									break;
@@ -372,27 +251,8 @@
 								else
 								if ( current_pos_v->backlinks == 1 )
 								{ /* follow the single link */
-									/**
-									 * ignore loops	to self 
-									 * avoids dos for "\xe3\xfe\xe8" 
-									 * breaks the upper loop 
-									 *  
-									 */
-									if( current_pos_v == emu_edges_first(current_pos_v->backedges)->destination )
-										break;
-									
-									current_pos_v = emu_edges_first(current_pos_v->backedges)->destination;
-									/**
-									 * again, ignore already visited positions 
-									 * breaks the upper loop 
-									 */
-									if( current_pos_v->color == red )
-										break;
 
-									current_pos_v->color = red;
-									
-									struct emu_source_and_track_instr_info *next_pos_satii =  (struct emu_source_and_track_instr_info *)current_pos_v->data;
-									logDebug(e, "FollowSingle %p %i %x %s\n", next_pos_satii, current_pos_v->color, next_pos_satii->eip, next_pos_satii->instrstring);
+									current_pos_v = emu_edges_first(current_pos_v->backedges)->destination;
 									current_pos_satii = (struct emu_source_and_track_instr_info *)current_pos_v->data;
 									emu_tracking_info_diff(current_pos_ti_diff, &current_pos_satii->track.init, current_pos_ti_diff);
 								}
@@ -400,30 +260,15 @@
 
 							if ( emu_tracking_info_covers(&current_pos_satii->track.init, current_pos_ti_diff) || brute_force )
 							{
-								/**
-								 * we have a new starting point, this starting point may fail
-								 * too - if further backwards traversal is required
-								 * therefore we mark it white, so it can be processed again
-								 */
 								logDebug(e, "found position which satiesfies the requirements %i %08x\n", current_pos_satii->eip, current_pos_satii->eip);
-								current_pos_ht = emu_hashtable_search(etas->static_instr_table, (void *)(uintptr_t)(uint32_t)current_pos_satii->eip);
-								current_pos_v = (struct emu_vertex *)current_pos_ht->value;
-
-								if(current_pos_satii->eip != current_offset )
-								{
-									logDebug(e, "marking white %p %x: %s \n", (uintptr_t)current_pos_v, current_pos_satii->eip, current_pos_satii->instrstring);
-									current_pos_v->color = white;
-								}
 								emu_tracking_info_debug_print(&current_pos_satii->track.init);
 								emu_queue_enqueue(eq, (void *)((uintptr_t)(uint32_t)current_pos_satii->eip));
 							}
-//discard:
 							emu_tracking_info_free( current_pos_ti_diff);
 						}
 						emu_queue_free(bfs_queue);
 					}
-					/** 
-					 * the shellcode did not run correctly as he was missing instructions initializing required registers
+					/* the shellcode did not run correctly as he was missing instructions initializing required registers
 					 * we did what we could do in the prev lines of code to find better offsets to start from
 					 * the working offsets got queued into the main queue, so we break here to give them a chance
                      */
@@ -440,15 +285,11 @@
 		es->cpu.steps = j;
 		struct emu_list_item *eli = emu_list_item_create();
 		eli->data = es;
-		logDebug(e, "INSERT %i %x steps %i\n", current_offset, current_offset, j);
 		emu_list_insert_last(stats_tested_positions_list, eli);
 	}
 
-
-	cpu->tracking = NULL;
-
 	emu_queue_free(eq);
-	emu_env_free(env);
+
 
 	/* sort all tested positions by the number of steps ascending */
 	emu_list_qsort(stats_tested_positions_list, tested_positions_cmp);
@@ -542,14 +383,10 @@
 									results, false);
 	}
 
-	
-
 	/* for all positions we got, take the best, maybe take memory access into account later */
 	emu_list_qsort(results, tested_positions_cmp);
 	if ( ((struct emu_stats *)emu_list_first(results)->data)->cpu.steps != 256 )
 	{
-		emu_hashtable_free(eh);
-		eh = emu_hashtable_new(size+4/4, emu_hashtable_ptr_hash, emu_hashtable_ptr_cmp);
 		logDebug(e, "brute force!\n");
 		struct emu_list_root *new_results = emu_list_create();
 		for ( eli = emu_list_first(results); !emu_list_attail(eli); eli = emu_list_next(eli) )
@@ -562,7 +399,6 @@
 		}
 
 		emu_list_concat(results, new_results);
-		emu_list_destroy(new_results);
 		emu_list_qsort(results, tested_positions_cmp);
 
 		/* uniq */
@@ -571,11 +407,7 @@
 			struct emu_list_item *next = emu_list_next(eli);
 			if (!emu_list_attail(next) &&
             	((struct emu_stats *)eli->data)->eip == ((struct emu_stats *)next->data)->eip )
-			{
-				emu_stats_free(next->data);
 				emu_list_remove(next);
-				free(next);
-			}
 		}
 	}
 
@@ -617,7 +449,7 @@
 	return offset - STATIC_OFFSET;
 }
 
-struct emu_stats *emu_stats_new(void)
+struct emu_stats *emu_stats_new()
 {
 	struct emu_stats *es = malloc(sizeof(struct emu_stats));
 	memset(es, 0, sizeof(struct emu_stats));
